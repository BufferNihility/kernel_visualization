#!/bin/bash

function usage() {
	echo $1
	echo "Usage:"
	echo " -e, --entry func, must options here"
	echo " -m, --modules modules, put multi modules splitted with comma(,)"
	echo " -f, --force_cache"
  echo " -o, --out_stap"
	echo " -v, --verbose, probe suffix ?"
  echo " e.g. ./gen_stap.sh -m iscsi_target_mod.ko,target_core_mod.ko,target_core_file.ko,target_core_pscsi.ko -e fd_do_rw"
}
function make_caches() {
	cache_dir=~/.kernel_visualization.cache
	modules_cache_file=$cache_dir/modules_list
	kfunc_cache_file=$cache_dir/kfunc_list
	mfunc_cache_file=$cache_dir/mfunc_list

	if [[ ( $force_cache -eq 1 ) || ( ! -d $cache_dir ) ]];then
		mkdir $cache_dir
		echo "Caching modules list"
		find /lib/modules/`uname -r`/ -type f -name "*.ko" > $modules_cache_file

		echo "Caching kernel funciton list"
		cat /boot/System.map-`uname -r` | grep -v ' U ' | awk '{print $3}' >$kfunc_cache_file

		echo "Caching modules funciton list"
		cat $modules_cache_file | while read m;do name=`basename $m .ko`;nm --defined-only $m | sed "s| t | $name |g";done | awk '{print $2, $3}' >$mfunc_cache_file
	fi
}

verbose=0
force_cache=0
cmd="$0 $@"
while [[ $# > 1 ]]
do
	key="$1"

	case $key in
		-e|--entry)
			entry="$2"
			shift # past argument
			;;
		-m|--modules)
			modules="$2"
			shift # past argument
			;;
		-o|--out)
			out_stap="$2"
			shift # past argument
			;;
		-v|--verbose)
			verbose=1
			;;
		-f|--force_cache)
			force_cache=1
			;;
		*)
			usage
			exit
			;;
	esac
	shift # past argument or value
done


[[ -z $entry ]] && usage && exit
[[ -z $out_stap ]] && out_stap=$entry.stap

calls=""
returns=""

make_caches

probe=$entry
found_probe=0
if [[ -n `cat $kfunc_cache_file | grep -w $entry` ]];then
	found_probe=1;probe='kernel.function("'$entry'")'
elif [[ -n `cat $mfunc_cache_file | grep -w $entry` ]];then
	found_probe=1;
	entry_module=`cat $mfunc_cache_file | grep -w $entry | awk '{print $1}'`
	probe=`cat $mfunc_cache_file | grep -w $entry | awk '{printf "module(\"%s\").function(\"%s\")", $1, $2}'`
  modules="$modules,$entry_module"
fi
[[ $found_probe -eq 0 ]] && usage "Couldn't find $entry" && exit

[[ -n $modules ]] && for i in ${modules//,/ }
do
	# find modules first
	if [ -z "`cat $modules_cache_file | grep -w $i`" ];then continue;fi
	i="module(\"$i\").function(\"*\")"
	if [[ -n $calls ]];then # non empty
		calls="$calls,\n  ""$i.call"
		returns="$returns,\n  ""$i.return"
	else
		calls="probe $i.call"
		returns="probe $i.return"
	fi
	[[ $verbose -eq 0 ]] && calls="$calls""?"
	[[ $verbose -eq 0 ]] && returns="$returns""?"
done

if [ -z "$calls" ];then
	calls="probe kernel.function(\"*\").call?"
	returns="probe kernel.function(\"*\").return?"
fi

echo "[+] Entry func: $probe"
echo "[+] Inject modules: $modules"
echo "[+] Out_stap: $out_stap"
echo "[+] Force cache: $force_cache"
echo "[+] Probe check: $verbose"


sed -e "s/\$1/$probe/g" -e "s/probe \$2.call/$calls/g" -e "s/probe \$2.return/$returns/g" stap_base.stp >$out_stap
cat >>$out_stap <<EOF
##############################################################################
#                      Generated by gen_stap.sh using cmd:
#                          $cmd
#                      Author: Feng Li (lifeng1519@gmail.com)
EOF
chmod a+x $out_stap
cat $out_stap
